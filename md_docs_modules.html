<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>beman::execution: Supporting Modules</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
 <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
 <script type="text/javascript">
     DoxygenAwesomeDarkModeToggle.init()
 </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="beman-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">beman::execution
   </div>
   <div id="projectbrief">Building Block For Asynchronous Programs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_modules.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Supporting Modules </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Author: Dietmar KÃ¼hl <a href="#" onclick="location.href='mai'+'lto:'+'die'+'tm'+'ar.'+'ku'+'ehl'+'@m'+'e.c'+'om'; return false;">dietm<span class="obfuscator">.nosp@m.</span>ar.k<span class="obfuscator">.nosp@m.</span>uehl@<span class="obfuscator">.nosp@m.</span>me.c<span class="obfuscator">.nosp@m.</span>om</a> Date: 2026-02-05</p>
<p>Originally <a href="https://github.com/bemanproject/execution"><code>beman.execution</code></a> was implemented with out <code>module</code> support. Eventually, <code>module</code> support in all compilers and in <a href="https://cmake.org/"><code>cmake</code></a> made it reasonable to add <code>module</code> support. This document describes some of the experiences of the journey adding <code>module</code> support for <a href="https://github.com/bemanproject/execution"><code>beman.execution</code></a>. It is likely that my attempts on how to support <code>module</code>s were misguided and I'm happy to learn how things can be done properly or better.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
History of Adding Module Support</h1>
<p>First, let's start describing what I did. The starting point for that was a working <a href="https://github.com/bemanproject/execution"><code>beman.execution</code></a> implementation which had no <code>module</code> support. It had tests and some examples and the <code>CMakeLists.txt</code> built these. The default build procedure run from the <code>Makefile</code> was already set up to use <code>ninja</code>.</p>
<p>Claus Klein had started to land <code>cmake</code> support of <code>module</code>s. In particular there were <code>cmake</code> rules to detect whether there is a dependency scanner and whether <code>import std;</code> is supported. The statement from Claus was that using <code>import std;</code> would be the second step - the first step is to actually create a <code>module</code> for <a href="https://github.com/bemanproject/execution"><code>beman.execution</code></a> including the standard library headers.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Use &lt;tt&gt;export using&lt;/tt&gt;</h2>
<p>I had tried to create a <code>module</code> right after the Hagenberg meeting at the end of 2025. Since I was clueless how to go about that I had asked people who worked on the <code>module</code> specification and implemented the corresponding support in compilers. The recommendation was to create a <code>module</code> file, include all the headers, start the <code>module</code>, and have <code>export using &lt;name&gt;;</code> declarations. That is, something like this:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">module;</div>
<div class="line"> </div>
<div class="line">#include &lt;beman/execution/execution.hpp&gt;</div>
<div class="line"> </div>
<div class="line">export module beman.execution;</div>
<div class="line"> </div>
<div class="line">namespace beman::execution {</div>
<div class="line">    export using ::beman::execution::forwarding_query_t;</div>
<div class="line">    // more of these - one for each name to be exported</div>
<div class="line">}</div>
</div><!-- fragment --><p>Creating a file like that was fairly mechanical work and I just did it. I tried it. There were a bunch of errors which I could work out easily but eventually I got stuck with inscrutable errors. Since I never planned to write about the experience I don't recall what the errors were. When I asked about it the message was that neither <code>cmake</code> nor the compilers are quite there. So I abandoned this first attempt.</p>
<p>Time passed and in the beginning of 2026 some <code>cmake</code> support for <code>module</code>s was added via a PR to the repository. The code wasn't ready to use <code>module</code> but it seems reasonable to retry. A first feeble try to get things built using the <code>export using</code> approach again resulted in errors and there were voice stating that this won't work but <code>module</code> support should actually work. The error messages seemed to imply that I should <code>export</code> the declarations immediately. So I abandoned that particular approach, again.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Generate Module Friendly Code: &lt;tt&gt;mk-module.py&lt;/tt&gt;</h2>
<p>The attempts up to this point had indicated a few things which were somewhat misaligned with the way the code in <a href="https://github.com/bemanproject/execution"><code>beman.execution</code></a> is laid out. The code is structured into lots of small <em>components</em> (loosely based on John Lakos's idea of components in his 1996 version of "Large-Scale C++"). Each component consists of</p>
<ul>
<li>
a header declaring an entity like a class/class template, a function/function template, or a concept as well as everything needed to do so;  </li>
<li>
a test file verifying that everything promised is, indeed, defined and confirm using tests that it works;  </li>
<li>
an optional source file with the definitions of what is declared in the header; in case of templates the header will actually contain these definitions  </li>
</ul>
<p>Each component's file includes all necessary headers and a component <code>A</code> is said to <em>directly depend on a component</em> <code>D</code> if any of <code>A</code>'s files includes <code>D</code>'s header. Creating a graph with the components as nodes and directed edges from each component to all components it directly depends on results in dependency graph which does not contain any cycles. Building the code without <code>module</code>s just works fine.</p>
<p>When trying directly <code>export</code> the declarations of names when they are first declared, it quickly transpired that this doesn't work due to the structure of <code>module</code> files required by contemporary compilers:</p>
<ol>
<li>
The first 7 characters of a <code>module</code> file shall be <code>module;</code> without anything preceding them. <a href="https://gcc.gnu.org/"><code>g++</code></a> and <a href="https://llvm.org/"><code>clang++</code></a> are somewhat relaxed about this requirement but some compiler is rather strict. This, however, is at least easily achieved.  </li>
<li>
Any <code>export</code> of a name has to follow the <code>module</code>'s name declaration, in this case after <code>export module <a class="el" href="namespacebeman_1_1execution.html" title="Namespace for asynchronous operations and their vocabulary.">beman.execution</a>;</code>. This makes sense: the compiler needs to know what <code>module</code> the names belong to.  </li>
<li>
The problem comes with any standard library header included after this name declaration: that entirely confuses the compilers. That is, all headers really need to be included before the name declaration. That is pretty much <em>not</em> how the components in <a href="https://github.com/bemanproject/execution"><code>beman.execution</code></a> are organized.  </li>
</ol>
<p>To still achieve the objective of <code>export</code>ing a name when it first gets declared, the structure needs to be changed. However, the components are organized in a consistent structure. So the idea is to use this structure to reorganize the files for <code>module</code> builds:</p>
<ol>
<li>
Add an <code>export</code> keyword in front of any declaration which should be <code>export</code>ed (well, really a name which can be defined so the headers can function both when building a <code>module</code> and when just using headers; the implementation uses <code>BEMAN_EXECUTION_EXPORT</code>).  </li>
<li>
Use a script (named <a href="https://github.com/bemanproject/execution/blob/main/bin/mk-module.py"><code>bin/mk-module.py</code></a>) to create a <code>module</code> definition: <ol>
<li>
Start the file with <code>module;</code> (and some header stating the file is generated).  </li>
<li>
Create a list of all used standard library headers and put these right below the files head.  </li>
<li>
Add the <code>module</code> name declaration.  </li>
<li>
Copy the declaration from all the components in correct dependency order, i.e., each component's declarations is preceded by the declarations it directly depends on.  </li>
</ol>
</li>
<li>
Profit! </li>
</ol>
<p>Creating the script to write the file was reasonably straight forward although I spend way too much time making it fancy and include suitable <code>#line</code> directives to find the actual source. Compiling the resulting still didn't quite work, of course. There was a bunch of silly errors in the component headers which could be quickly resolved, though. That wasn't quite as true for the test files, though (more rumination on tests below):</p>
<ul>
<li>Many tests didn't include all standard library headers they dependent on. Since the corresponding header were actually included by a component header things still worked. So, the corresponding headers needed to be added.</li>
<li>Instead of <code>#include &lt;<a class="el" href="execution_2execution_8hpp_source.html">beman/execution/execution.hpp</a>&gt;</code> the tests now use <code>import <a class="el" href="namespacebeman_1_1execution.html" title="Namespace for asynchronous operations and their vocabulary.">beman.execution</a>;</code> (well, the test really use conditional compilation to either use a header or an <code>import</code> statement). Including any standard library header <em>after</em> the <code>import</code> statement again confuses the compiler, i.e., some reordering in the files was needed: the test files deliberately included the component's header first (to make sure all needed headers are included by the component header) but this include statement is now replaced by the <code>import</code> statement.</li>
<li>The tests actually use some of the implementation-defined entities which were not meant to be <code>export</code>ed. To still have these tests I ended up <code>export</code>ing the necessary implementation-defined names. That needs to be corrected eventually (assuming that is actually possible which isn't quite as clear).</li>
<li>Of course, the tests actually used the various names and it turned out that quite a few names, e.g., the <code>operator|</code>, were missing.</li>
</ul>
<p>That worked OK with one compiler. Then I tried a different compiler and lots of issues emerged:</p>
<ul>
<li>More names needed to be <code>export</code>ed for the tests.</li>
<li>Some things just didn't compile at all and needed to be changed (I managed to avoid the problems but I haven't quite understood why).</li>
<li>Symbols were undefined.</li>
</ul>
<p>I ended up spending quite a bit of time reshuffling where headers go, fixing some actual bugs, and working around what looks like compiler problems. Most of that was, however, fairly mechanical and eventually I got a <code>module</code> declaration working with all major C++ compilers (using recent versions of each).</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Retry &lt;tt&gt;export using&lt;/tt&gt;</h2>
<p>Using a script to generate a <code>module</code> file restructured to better match the <code>module</code> needs did get me a working <code>module</code> definition. However, that shouldn't really be necessary. While fixing various minor bugs I did fix a few things which looked as if they may have had an impact when trying to use <code>export using &lt;name&gt;</code>. So tried that approach again and this time it worked, at least, for some of the compilers. That looked promising!</p>
<p>One compiler put up a fight, though! I'm using the an exposition-only <code>product_type</code> class template as is described in <a href="https://eel.is/c++draft/exec#snd.expos-17">[exec]</a> and I got a compiler error about using <code>std::get&lt;N&gt;(<em>sender</em>)</code>. After some experimentation I found that <code>export</code>ing the <code>product_type</code> template and the relevant <code>tuple_size</code> and <code>tuple_element</code> specialization I could resolve this problem, too.</p>
<p>Once I got past that I encountered a problem which is probably quite common: following the specification of exposition-only <code>impls_for</code> class template I used lambda functions for the various "overrides". One compiler complained about undefined symbols about these! Of course, using lambda functions in a header is problematic because each instance of a lambda function has a different type, even if they are spelled identical! So I replaced all of these lambda functions by <code>struct</code>s which only have one member which is an <code>operator()</code>.</p>
<p>With that I also got a working <code>module</code> definition. While I'm quite fond of my generator I prefer this approach! There shouldn't be a need to rewrite an implementation just to make it a <code>module</code>. I should also get away not needing any macros to insert/remove the <code>export</code> keywords from declarations. Instead, the <code>export</code>ed names are just listed in the module definition file. What is currently missing is a bit of a clean-up to remove some of the artifacts. Also, there may be more implementation details exported than is actually necessary.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
&lt;tt&gt;import std;&lt;/tt&gt;</h2>
<p>Currently, <code>import std;</code> is <em>not</em>, yet, used. It should be straight forward to conditionally choose between <code>import std;</code> and including the headers.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Changes Needed to Support Modules</h1>
<p>When enabling modules I needed to apply quite a few, mostly rather simple changes. Some of the necessary changes did take me a bit to actually discover. Here is broadly what I needed to change:</p>
<ul>
<li>I had slotted and <code>import <a class="el" href="namespacebeman_1_1execution.html" title="Namespace for asynchronous operations and their vocabulary.">beman.execution</a>;</code> in where the the project header(s) were included. Some headers came before, others came after. It seems that doesn't work: any header should preceded the <code>import</code> statements or the <code>module</code> name declaration.</li>
<li><p class="startli">Especially in the tests I hadn't always included all headers for standard library components which may be potentially used. However, these are necessary, even if the standard library component isn't even named and just used. For example:</p>
<div class="fragment"><div class="line">{c++}</div>
<div class="line">   #include &lt;tuple&gt;</div>
<div class="line">   import beman.execution;</div>
<div class="line">   namespace ex = beman::execution;</div>
<div class="line"> </div>
<div class="line">   int main() {</div>
<div class="line">       auto[rc] = *ex::sync_wait(ex::just(0));</div>
<div class="line">       return rc;</div>
<div class="line">   }</div>
</div><!-- fragment --><p class="startli">Removing <code>#include &lt;tuple&gt;</code> causes a compilation failure: <code>sync_wait</code> return an <code>std::optional&lt;std::tuple&lt;T...&gt;&gt;</code> and the structured binding needs to know about the <code>std::tuple</code>. Oddly, the <code>std::optional</code> can be dereferenced.</p>
</li>
<li><p class="startli">My biggest blocker was the definition of <code>join_env</code>: the original definition used a <code>requires</code> clause which checked whether at least one of two expressions were values. Implementation used an <code>if constexpr</code> to decide whether the first of the two expression is value and used that and otherwise the other expression would be used. That is, something like this:</p>
<div class="fragment"><div class="line">{c++}</div>
<div class="line">   template &lt;typename E1, typename E2&gt;</div>
<div class="line">   struct join_env {</div>
<div class="line">       E1 e1;</div>
<div class="line">       E2 e2;</div>
<div class="line">       template &lt;typename Q&gt;</div>
<div class="line">           requires(</div>
<div class="line">               requires(Q q, const E1&amp; e){ q(e); } ||</div>
<div class="line">               requires(Q q, const E2&amp; e){ q(e); }</div>
<div class="line">           )</div>
<div class="line">       auto query(Q q) const noexcept {</div>
<div class="line">           if constexpr (requires(Q q, const E1&amp; e){ q(e); })</div>
<div class="line">               return q(this-&gt;e1);</div>
<div class="line">           else</div>
<div class="line">               return q(this-&gt;e2);</div>
<div class="line">       }</div>
<div class="line">   };</div>
</div><!-- fragment --><p class="startli">However, the compiler insisted in the definition of the function that neither of the two expressions from the <code>requires</code> clause was valid. Eventually I just turned the <code>query</code> into two overloads, the first requiring that <code>q(e1)</code> is valid and the second requiring that <code>q(e1)</code> is not valid but <code>q(e2)</code> is valid. I think it was only one compiler causing this issue.</p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md9"></a>
Scanning and Building</h1>
<p>One of the things which seems odd is that each time <code><a class="el" href="namespacebeman_1_1execution.html" title="Namespace for asynchronous operations and their vocabulary.">beman.execution</a></code> is built, the files are scanned for dependencies. That scanning often takes longer than the actual build of the respective object file. Also, since the <code>module</code> gets rebuild, all the tests <code>import</code>ing the <code>module</code> get built again. When developing with including headers only the tests which included modified headers (possibly indirectly) needed to be rebuilt. Since the components and tests were created in dependency order, that normally meant that only one test needed to be rebuilt. Only if an already tested component needed to be changed multiple tests needed to be built.</p>
<p>The promise of <code>module</code>s was that builds get faster. I don't have objective measurements but it seems the development actually got slower. While concentrating on fixing a particular component I often removed all other tests and the examples from the build.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Modules vs. Testing</h1>
<p>Testing the <code>module</code> components is, yet, another issue! There are a few issues and I haven't worked out all of them, yet:</p>
<ol type="1">
<li><p class="startli">There are quite a few classes and functions which are implementation details. I like to test these. In fact, I normally don't use <code>private</code> member functions because I can't test them. Instead, this functionality would become <code>public</code> members of an implementation class which then becomes a <code>private</code> member of the actual component. The implementation class can be tested separately. However, anything which isn't <code>export</code>ed isn't accessible from outside the <code>module</code>.</p>
<p class="startli">I still want to test that the <code>module</code> works, including all the implementation details. Currently, the implementation details are tested by just using the headers to get the declarations. That doesn't seem quite right, though. Maybe the way to is to have a second <code>module</code> for the implementation details, say, <code>beman.execution.detail</code>, and use that to test the implementation details.</p>
</li>
<li><p class="startli">Some tests would benefit from common tools. For example, there could be a <code>test::scheduler</code> which is used to verify that the various scheduling operations do the right thing. A <code>test::scheduler</code> would be defined in a header and included into each test. Of course, the <code>test::scheduler</code> would need the declarations of some <code>module</code> components, e.g., of <code>set_value_t</code> and, thus, use <code>import <a class="el" href="namespacebeman_1_1execution.html" title="Namespace for asynchronous operations and their vocabulary.">beman.execution</a></code>.</p>
<p class="startli">That didn't quite occur to me but it <em>seems</em> that may actually work! An initial test seems to show that the compilers do not get upset about multiple <code>import <a class="el" href="namespacebeman_1_1execution.html" title="Namespace for asynchronous operations and their vocabulary.">beman.execution</a></code> statements.</p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md11"></a>
Conclusion</h1>
<p>So far it isn't clear to me whether <code>module</code>s do provide a benefit. The main sticking points are:</p>
<ol type="1">
<li>I don't known, yet, how to test implementation details without <code>export</code>ing them.</li>
<li>The "scan deps" step seems to take quite long.</li>
<li>So far I haven't managed to avoid <code>export</code>ing some of the implementation details. However, that <em>may</em> be due to some uses actually requiring them.</li>
<li>There is different behavior between different compilers.</li>
</ol>
<p>Some of the issues I encountered are likely due to ignorance: probably all issues can be resolved with a bit of adjusted practices. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
